;; -*-lisp-*-
;;
;; TODO: Wrap desktop-scale function.
;; TODO: Organize everything into hooks.
;; TODO: Idea: automatically place newly opened windows somewhere on plane.
;;       Addition: user toggle whether to automatically pan and focus those windows.
;; DONE: Keys/commands to resize windows to certain sizes (full/half-screen, etc.)
;;       This will take shape as a sort-of tiling mode.
;; TODO: Command to adjust window to certain position.
;;       Find window to particular side and align current window to that one.
;;       Offer options for both moving and resizing on each side of the window.
;;       Make quick option for adjusting to the closest window.
;; TODO: Consider regex or template-string method to have live-updating commands.
;;       Look into StumpWM timers for this.
;; TODO: Improve window search algorithms.
;;       What needs to be done for this?
;; DONE: UTF-8 support in bar.
;; DONE: Automatically fill bar above windows with commands.
;; TODO: Save window bar strings.
;;       Look into StumpWM state-saving.
;; DONE: Why do the bars erase all their text sometimes?
;; DONE: Properly size bar on top of application.
;; DONE: Improve styling (Change orange wrap-around to another color, etc).
;; TODO: Next/previous window functions.
;;       Should operate inside view and simply operate on cycle.
;;       Eventually use reinforcement learning to predict the next window.
;;       Also include option for ordering based on focus (like Alt+Tab).
;; DONE: Properly exit from bar after executing a command.
;; TODO: Take everything from .stumpwmrc and put into proper files.
;;       Could be split into overview and non-overview functions.
;; TODO: Fill the bar with spaces to allow for typing anywhere.
;;       Delete spaces on the end to keep it even, and fill it with spaces when
;;       words are deleted.
;; DONE: Improve maximize function.
;; DONE: Get rid of cursor when not clicked.
;; DONE: Right arrow kills window?
;; TODO: Redraw bar as window is resized.
;; DONE: Base colors off current color variables.
;; TODO: Bonus: Refresh current bars.
;; TODO: K-means clustering
;; TODO: Tree-style window list bar on the side for seeing which applications are open
;;        (plus more?)
;;        This comes from the tree-style tabs extensions on Firefox, which list many tabs.
;; TODO: StumpWM echoes "Command T is not found" occasionally when executing on the bar.
;; TODO: Idea: radially zoom out. So zoom out to bounding box of windows
;;       surrounding current window, then the windows surrounding those, etc.
;;       This would probably be tricky to implement, since it would ideally create
;;       a perfect-ish bounding box of the first n windows around the current center window.
;;       Idea for implementation: get bounding box of (up down left right), then
;;       get the bounding box of the up window for the up window, the down for the down,
;;       etc. So (up^2 down^2 left^2 right^2) ... (up^n down^n left^n right^n)
;; TODO: Move screen when the window is dragged to the side.
;;       This will need timing to work well.
;; TODO: Visual mode to select and move windows.

(in-package :stumpwm)
(require 'dbus)

;; Load swank.
(require 'swank)
(swank:create-server
 :port 4005
 :style swank:*communication-style*
 :dont-close t)

(load-module "ttf-fonts")
;;(set-font (make-instance 'xft:font :family "Anonymous Pro" :subfamily "Bold" :size 13))
(set-font (make-instance 'xft:font :family "DejaVu Sans Mono" :subfamily "Book" :size 12))
(set-bg-color "white")
(set-fg-color "black")
(set-float-focus-color "white")
(set-float-unfocus-color "gray")

(declaim (optimize (debug 3)))

;; ▓
(setq *default-command-list*
  '(((eval-command "delete") "Ø")
    ((eval-command "maximize 1 1 top left") "[▒▒]")
    ((eval-command "maximize 2 1 top left") "[▒ ]")
    ((eval-command "maximize 2 1 top right") "[ ▒]")
    ((eval-command "left") "«——")
    ((eval-command "right") "——»")
    ((funcall #'add-win) "+++" )))

(setq *mouse-focus-policy* :sloppy)
(setq *debug-level* 0)
(redirect-all-output (data-dir-file "debug-output" "txt"))

(defstruct (win-geometry (:constructor %make-win-geometry))
  id
  center
  min
  max)

(defstruct edge
  source-node
  target-node
  dir
  dist)

(defstruct win-node
  win
  id
  geometry
  up
  down
  left
  right)

(defvar *last-focused* nil)
(defvar *window-graph* (make-hash-table))

;; TODO: Move the mouse to maintain its position relative to the window.
(defcommand maximize
    (&optional (width-div 1) (height-div 1) (t-b "top") (l-r "left"))
    ((:number "Enter width divisor ")
     (:number "Enter height divisor ")
     (:string "Enter top/bottom ")
     (:string "Enter side "))
  "Maximizes the current window"
  (let* ((new-width (/ (- (screen-width (current-screen))
                          (- (xlib:drawable-width (window-parent (current-window)))
                             (window-width (current-window)))
                          (* 2 *float-window-border*))
                       width-div))
         (new-height (/ (- (screen-height (current-screen))
                           (- (xlib:drawable-height (window-parent (current-window)))
                              (window-height (current-window)))
                           (* 2 *float-window-border*))
                        height-div))
         (new-x (switch (l-r :test #'equal)
                  ("left"
                   0)
                  ("right"
                   (- (screen-width (current-screen)) new-width))))
         (new-y (switch (t-b :test #'equal)
                  ("top"
                   0)
                  ("bottom"
                   (- (screen-height (current-screen)) new-height)))))
    (float-window-move-resize
     (current-window)
     :x new-x
     :y new-y
     :width new-width
     :height new-height)))

(defcommand left () ()
  "Temporary until I implement bar subtitutions"
  (eval-command (format nil "pan-group ~a ~a"
                        (screen-width (current-screen))
                        0)))

(defcommand right () ()
  "Temporary until I implement bar subtitutions"
  (eval-command (format nil "pan-group ~a ~a"
                        (* -1 (screen-width (current-screen)))
                        0)))

;; change the prefix key to something else
(set-prefix-key (kbd "C-;"))

;; prompt the user for an interactive command. The first arg is an
;; optional initial contents.
(defcommand colon1 (&optional (initial "")) (:rest)
  (let ((cmd (read-one-line (current-screen) "◉ " :initial-input initial)))
    (when cmd
      (eval-command cmd t))))

(eval-command "gnewbg-float float" nil)
(eval-command "gkill" nil)

(define-key *root-map* (kbd "s-h") "pan-group 1920 0")
(define-key *root-map* (kbd "s-j") "pan-group 0 -1200")
(define-key *root-map* (kbd "s-k") "pan-group 0 1200")
(define-key *root-map* (kbd "s-l") "pan-group -1920 0")
(define-key *root-map* (kbd "s-o") "view-all-in-group")

(define-key *root-map* (kbd ".") "colon")

(defvar *current-scale* 100)
(defvar *scaled-hook* '(overview-mouse-control))

(defstruct point x y)

(defvar *current-offset* (make-point :x 0 :y 0))

(defstruct view
  win coords scale)

(defvar *views* (make-array 10))
(defvar *views-map* nil)
(define-key *root-map* (kbd "V") "version")
(define-key *root-map* (kbd "v") '*views-map*)

(defun scale-value (val)
  (round (* val (/ *current-scale* 100))))

;;(defvar *scaled* nil)
;; TODO: Make wrapper that makes this easier to work with.
(defun scale-desktop (amount)
  (dbus:with-open-bus (bus (dbus:session-server-addresses))
    (dbus:with-introspected-object (compton bus "/" "com.github.chjj.compton._1_0")
      (compton "com.github.chjj.compton" "scale" (float (/ amount 100))))))

(defun pan-desktop-visual (x y)
  (incf (point-x *current-offset*) x)
  (incf (point-y *current-offset*) y)
  (dbus:with-open-bus (bus (dbus:session-server-addresses))
    (dbus:with-introspected-object (compton bus "/" "com.github.chjj.compton._1_0")
      (compton "com.github.chjj.compton" "offset" x y))))

;; Make smaller.
(defcommand scale-up (amount) ((:number "Enter scale increase: "))
  (setq *current-scale* (+ *current-scale* amount))
  (scale-desktop *current-scale*)
  ;; We just started scaling, capture the mouse.
  (if (and (= (- *current-scale* amount) 100) (not (= amount 0)))
      (run-hook *scaled-hook*)))

;; Make bigger.
(defcommand scale-down (amount) ((:number "Enter scale decrease: "))
  (cond ((not (and (= *current-scale* 100) (not (= amount 0))))
      (setq *current-scale* (- *current-scale* amount))
      (if (and (= *current-scale* 100) (not (= amount 0)))
          (ungrab-pointer))
      (scale-desktop *current-scale*))))

(defcommand reset-scale () ()
  (setq *current-scale* 100)
  (scale-desktop *current-scale*))

(define-key *root-map* (kbd "quoteleft") "scale-up 10")
(define-key *root-map* (kbd "~") "scale-down 10")
(define-key *root-map* (kbd "@") "reset-scale")
(define-key *root-map* (kbd "]") "scale-up 100")
(define-key *root-map* (kbd "[") "scale-down 100")

(defun find-value (val lst)
  (cond
    ((null lst) 'value-not-found)
    ((eq val (car lst)) (cadr lst))
    (T (find-value val (cddr lst)))))

(defcommand record-view (number) ((:number "View number: "))
  (let* ((win (current-window))
        (coords (make-point
                 :x (window-x win)
                 :y (window-y win))))
    (setf (elt *views* (- number 1))
          (make-view
           :win win
           :coords coords
           :scale *current-scale*))))

(defcommand activate-view (number) ((:number "View number: "))
  (let* ((view (elt *views* (- number 1)))
         (win (view-win view))
         (coords (view-coords view))
         (cur-win-x (window-x win))
         (cur-win-y (window-y win)))
    (pan-group (- (point-x coords) cur-win-x)
               (- (point-y coords) cur-win-y))
    (scale-desktop (view-scale view))
    (setq *current-scale* (view-scale view))
    (when (> (view-scale view) 100)
        (run-hook *scaled-hook*))))

(fill-keymap *views-map*
             (kbd "F1")    "record-view 1"
             (kbd "F2")    "record-view 2"
             (kbd "F3")    "record-view 3"
             (kbd "F4")    "record-view 4"
             (kbd "F5")    "record-view 5"
             (kbd "F6")    "record-view 6"
             (kbd "F7")    "record-view 7"
             (kbd "F8")    "record-view 8"
             (kbd "F9")    "record-view 9"
             (kbd "F10")   "record-view 10"
             (kbd "1")     "activate-view 1"
             (kbd "2")     "activate-view 2"
             (kbd "3")     "activate-view 3"
             (kbd "4")     "activate-view 4"
             (kbd "5")     "activate-view 5"
             (kbd "6")     "activate-view 6"
             (kbd "7")     "activate-view 7"
             (kbd "8")     "activate-view 8"
             (kbd "9")     "activate-view 9"
             (kbd "0")     "activate-view 10")

#|
DONE: Implement a basic form of "view."
Create an array that holds view structs.
To save a view:
1.) Record the current window.
2.) Record its coords.
3.) Record the current scale.

To activate a view:
1.) Get the window from the view and its coords.
2.) Get the saved coords.
3.) Pan to the difference between those coords.
4.) Set the scale to the saved scale.
|#

(defun get-list-bounding-box (list-of-windows &key min-x min-y max-x max-y )
  "Get the coordinates that contain a given list of windows."
  (if (null list-of-windows)
      (list (list min-x min-y) (list max-x max-y))
      (let* ((win (car list-of-windows))
             (parent (window-parent win))
             (win-min-x (xlib:drawable-x parent))
             (win-min-y (xlib:drawable-y parent))
             (win-max-x (+ win-min-x (xlib:drawable-width parent)))
             (win-max-y (+ win-min-y (xlib:drawable-height parent))))
        (cond ((or (null min-x) (null min-y) (null max-x) (null max-y))
               (setq min-x win-min-x)
               (setq min-y win-min-y)
               (setq max-x win-max-x)
               (setq max-y win-max-y)))
        (when (<= win-min-x min-x) (setq min-x win-min-x))
        (when (<= win-min-y min-y) (setq min-y win-min-y))
        (when (>= win-max-x max-x) (setq max-x win-max-x))
        (when (>= win-max-y max-y) (setq max-y win-max-y))
        (get-list-bounding-box
         (cdr list-of-windows) :min-x min-x :min-y min-y :max-x max-x :max-y max-y))))

(defun get-win-extents (win)
  "Get the extents for a single window"
  (get-list-bounding-box (list win)))

(defun get-bounding-box-scale (box-width box-height)
  (let* ((width (max box-width (screen-width (current-screen))))
         (height (max box-height (screen-height (current-screen))))
         (scale-width (/ width (screen-width (current-screen))))
         (scale-height (/ height (screen-height (current-screen))))
         (final-scale (* 100 (max scale-width scale-height))))
    ;;(print (list width height scale-width scale-height))
    final-scale))

(defcommand echo-bounding-box () ()
  (echo (get-list-bounding-box (group-windows (current-group)))))

(defcommand view-all-in-group () ()
  (let* ((group-extents (get-list-bounding-box (group-windows (current-group))))
         (min-coords (first group-extents))
         (max-coords (second group-extents))
         (min-x (first min-coords))
         (min-y (second min-coords))
         (max-x (first max-coords))
         (max-y (second max-coords))
         (scale (get-bounding-box-scale (- max-x min-x) (- max-y min-y))))
    (cond ((or (> (- max-x min-x) (screen-width (current-screen)))
               (> (- max-y min-y) (screen-height (current-screen))))
           (pan-group (- 0 min-x)
                      (- 0 min-y))
           (setq *current-scale* scale)
           (scale-desktop scale)
           (run-hook *scaled-hook*)))))

(defun zoom-to-window (win align)
  (let* ((extents (get-win-extents win))
         (min-coords (first extents))
         (max-coords (second extents))
         (min-x (first min-coords))
         (min-y (second min-coords))
         (max-x (first max-coords))
         (max-y (second max-coords))
         (scale (get-bounding-box-scale (- max-x min-x) (- max-y min-y)))
         (offset-x 0)
         (offset-y 0))
    (cond
      ((equal align 'left)
       (setq offset-x 0)
       (setq offset-y 0))
      ((equal align 'center)
       (if (= scale 100)
           (progn
             (setq offset-x (round (/ (- (screen-width (current-screen)) (- max-x min-x)) 2)))
             (setq offset-y (round (/ (- (screen-height (current-screen)) (- max-y min-y)) 2))))
           (progn
             (setq offset-x (- min-x max-x))
             (setq offset-y (- min-y max-y))))))
    (pan-group (- offset-x min-x)
               (- offset-y min-y))
    (setq *current-scale* scale)
    (scale-desktop scale)
    #|(if (> scale 100) (run-hook *scaled-hook*))|#))

(defun find-window-to-side (cur-coord get-coord compare closest-win current-best lst)
  (if (null lst)
      (if (funcall compare (funcall get-coord closest-win) cur-coord)
          (values closest-win current-best)
          nil)
      (let ((cur-dist (abs (- cur-coord (funcall get-coord (car lst))))))
        (if (or (equal current-best nil) (< cur-dist current-best))
            (progn
              (setq current-best cur-dist)
              (setq closest-win (car lst))))
        (find-window-to-side cur-coord get-coord compare closest-win current-best (cdr lst)))))

(defun filter-outside-boundaries (min max fn lst)
  "Takes a max and min for the current window, and filters out
   all windows whose min coord is greater than the max, or whose
   max coord is less than the min."
  (remove-if (lambda (win)
               (or (< (funcall fn (win-geometry-max win)) min)
                   (> (funcall fn (win-geometry-min win)) max)))
             lst))

;; Only returns windows that cross the line on a particular axis.
(defun filter-outside-line (line fn lst)
  (remove-if-not (lambda (win)
                   (and (> line (funcall fn (win-geometry-min win)))
                        (< line (funcall fn (win-geometry-max win)))))
                 lst))

;; Take the direction and find the window with the nearest
;; (x, y) coordinates in that direction.
;; Move to that window (centered or on left).
;; Must consider both position and distance when finding window.
;;
;; +---A--+
;; |      |  +--B-+
;; |      |  +----+
;; +------+ +--C-+
;;          +----+
;; This would select B, not C.
;; ---------------------------
;;
;; +---A--+
;; |      |           +--B-+
;; |      |           +----+
;; +------+ +--C-+
;;          +----+
;; Would this select B or C?
;; ---------------------------
;;
;; +---A--+
;; |      |
;; |      |
;; +------+
;;
;;          +--B-+
;;          +----+
;; Probably would select B.
;; ---------------------------
;;
;; Cases:
;;   - Window is on side and intersects the middle-line of the current window.
;;   - Window is within the width/height of current window.
;;     - e.g. searching on right: window's top/bottom y-coords intersect the
;;       current window's top/bottom y-coords.
;;   - Window doesn't intersect either line, but is closest on corresponding side.
;;
;; TODO: Make three levels of searching, and allow stopping at a specified level:
;;       1.) Crosses middle
;;       2.) Within window borders
;;       3.) Anywhere on that side of the window.
(defun locate-closest-window (geom win-list dir)
  (when (not (null win-list))
    (let* ((min-x (point-x (win-geometry-min geom)))
           (min-y (point-y (win-geometry-min geom)))
           (max-x (point-x (win-geometry-max geom)))
           (max-y (point-y (win-geometry-max geom)))
           (compare nil)
           (get-coord nil)
           (val 0)
           (x-median (point-x (win-geometry-center geom)))
           (y-median (point-y (win-geometry-center geom)))
           (dist 0)
           ;; (win-list-outside-boundaries nil)
           (win nil)
           (win-list-filtered nil))
      ;; TODO: Should use structure.
      (switch (dir :test #'equal)
        ("up"
         (setq compare #'<=)
         (setq get-coord (lambda (win) (point-y (win-geometry-max win))))
         (setq win-list-filtered (filter-outside-line x-median #'point-x win-list))
         (setq val min-y))
        ("down"
         (setq compare #'>=)
         (setq get-coord (lambda (win) (point-y (win-geometry-min win))))
         (setq win-list-filtered (filter-outside-line x-median #'point-x win-list))
         (setq val max-y))
        ("left"
         (setq compare #'<=)
         (setq get-coord (lambda (win) (point-x (win-geometry-max win))))
         (setq win-list-filtered (filter-outside-line y-median #'point-y win-list))
         (setq val min-x))
        ("right"
         (setq compare #'>=)
         (setq get-coord (lambda (win) (point-x (win-geometry-min win))))
         (setq win-list-filtered (filter-outside-line y-median #'point-y win-list))
         (setq val max-x)))
      ;;(print win-list-filtered)
      ;;(echo win-list-filtered)
      ;; (dformat 0 "Win-list: ~a~% Win-list-filtered: ~a~%" win-list win-list-filtered)
      (multiple-value-setq
          (win dist)
        (find-window-to-side val get-coord compare nil nil (or win-list-filtered win-list)))
      ;; First heuristic: search within windows touching a line running
      ;; through the middle of the window.
      (if (not (null win))
          (values (win-geometry-id win) dist)
          (progn
            ;; Perform a wider search that simply finds the closest window.
            (multiple-value-setq
                (win dist)
              (find-window-to-side val get-coord compare nil nil win-list))
            (if (not (null win))
                (values (win-geometry-id win) dist)
                nil))))))

(defcommand move-to-window (dir) ((:string "Enter direction: "))
  (if (or (equal dir "up") (equal dir "down") (equal dir "left") (equal dir "right"))
      (let* ((win-id (locate-closest-window
                  (group-current-window (current-group))
                  (remove (current-window) (group-windows (current-group)))
                  dir))
            (win (win-node-win (gethash win-id *window-graph*))))
        (if (not (null win))
            (progn
              (zoom-to-window win 'left)
              (focus-window win t))
            (echo "No window in that direction.")))
      (echo "Invalid direction. Allowed directions: up, down, left, right.")))


(defun list-to-string (lst)
  (format nil "~{~A~}" lst))

(defvar *zoom-map*
  (list
   (list (kbd "M-h") (list-to-string (list "pan-group " (+ 0 (head-width (current-head))) " " 0)))
   (list (kbd "M-j") (list-to-string (list "pan-group " 0 " " (- 0 (head-height (current-head))))))
   (list (kbd "M-k") (list-to-string (list "pan-group " 0 " " (+ 0 (head-height (current-head))))))
   (list (kbd "M-l") (list-to-string (list "pan-group " (- 0 (head-width (current-head))) " " 0)))
   (list (kbd "M-H") "move-to-window left")
   (list (kbd "M-J") "move-to-window down")
   (list (kbd "M-K") "move-to-window up")
   (list (kbd "M-L") "move-to-window right"))
   "Keyamp set when in a zooming state for interacting with and manipulating windows.")


#|(fill-keymap *zoom-map*
             (kbd "g") '*groups-map*
             (kbd "v") "describe-variable"
             (kbd "f") "describe-function"
             (kbd "k") "describe-key"
             (kbd "c") "describe-command"
             (kbd "w") "where-is")|#

;;(xlib:grab-button (screen-root (current-screen))
;;                  1
;;                  '(:button-1-motion)
;;                  :modifiers '(:mod-1))

;;(xlib:ungrab-button (screen-root (current-screen))
;;                  1
;;                  :modifiers '(:mod-1))

(defun get-window-at-point (x y list-of-windows)
  (let ((win (car list-of-windows)))
    (cond
      ((null list-of-windows) 'root-window)
      ((and (>= x (window-x win))
            (>= y (window-y win))
            (<= x (+ (window-x win) (window-width win)))
            (<= y (+ (window-y win) (window-height win))))
       (car list-of-windows))
      (T (get-window-at-point x y (cdr list-of-windows))))))

(defcommand query-point (x y) ((:number "Enter x: ") (:number "Enter y: "))
    (echo (get-window-at-point
     (round (/ x
               (/ *current-scale* 100)))
     (round (/ y
               (/ *current-scale* 100)))
     (group-windows (current-group)))))

#|
;; BROKE
(defun apply-minor-mode (func map-layer keymaps)
  (funcall #'func map-layer (car keymaps))
  (apply-minor-mode map-layer (cdr keymaps)))

(defun toggle-zoom-minor-mode (enable)
  (defvar set-key nil)
  (if enable
      (setq set-key define-key)
      (setq set-key undefine key))
  (apply-minor-mode set-key *top-map* *zoom-map*))|#

(defun toggle-zoom-minor-mode (enable)
  (if enable
      (map 'nil (lambda (zoom-binding) (define-key
                                      *top-map*
                                      (first zoom-binding)
                                    (second zoom-binding))) *zoom-map*)
      (map 'nil (lambda (zoom-binding) (undefine-key
                                      *top-map*
                                      (first zoom-binding))) *zoom-map*)))

#|(defun toggle-zoom-minor-mode ()
  ;;(defmacro set-ey)
      (undefine-key *top-map* (kbd "h") (list-to-string (list "pan-group " (+ 0 (head-width (current-head))) " " 0)))
      (undefine-key *top-map* (kbd "j") (list-to-string (list "pan-group " 0 " " (- 0 (head-height (current-head))))))
      (undefine-key *top-map* (kbd "k") (list-to-string (list "pan-group " 0 " " (+ 0 (head-height (current-head))))))
      (undefine-key *top-map* (kbd "l") (list-to-string (list "pan-group " (- 0 (head-width (current-head))) " " 0))))|#

(defun pan-centered-closure ()
  (let ((offset-x 0) (offset-y 0))
    (lambda ()
      (let* ((current-scale (/ *current-scale* 100))
             (width (* (head-width (current-head)) current-scale))
             (height (* (head-height (current-head)) current-scale))
             (cur-offset-x (round (-
                                   (/ width 2)
                                   (/ width
                                      (* current-scale 2)))))
             (cur-offset-y (round (-
                                   (/ height 2)
                                   (/ height
                                      (* current-scale 2))))))
        ;;(echo (list (- cur-offset-x offset-x) (- cur-offset-y offset-y)))
        (pan-group (- cur-offset-x offset-x)
                   (- cur-offset-y offset-y))
        (setq offset-x cur-offset-x)
        (setq offset-y cur-offset-y)))))

(defvar pan-centered (pan-centered-closure))

;; (prog1 nil (ungrab-pointer) (toggle-zoom-minor-mode nil))

(defun check-ungrab ()
  (echo "ungrabbing pointer")
  (ungrab-pointer))

(defun overview-mouse-control ()
  (toggle-zoom-minor-mode t)
  (let ((op nil) (cur-win nil) (prev-x 0) (prev-y 0) (win-x-diff 0) (win-y-diff 0))
   (labels ((overview-mouse-event-handler
               (&rest event-slots &key event-key &allow-other-keys)
             ;; MASKS (in event-slots):
             ;; left : 256
             ;; Middle : 512
             ;; Right: 1024
             ;; Scroll up: 2048
             ;; Scroll down: 4096
             ;;(if (= *current-scale* 100)
             ;;    (ungrab-pointer))
              (cond
                ((= *current-scale* 100) :done)
                (T
                 (case event-key
                   (:button-press
                    (setq prev-x (getf event-slots :x))
                    (setq prev-y (getf event-slots :y))
                    (setq cur-win
                          (get-window-at-point
                           (+ (round (scale-value (getf event-slots :x)))
                              (point-x *current-offset*))
                           (+ (round (scale-value (getf event-slots :y)))
                              (point-y *current-offset*))
                           (group-windows (current-group))))
                    (cond ((and (not (equal cur-win nil)) (not (equal cur-win 'root-window)))
                           (setq win-x-diff (- (scale-value (getf event-slots :x))
                                               (window-x cur-win)))
                           (setq win-y-diff (- (scale-value (getf event-slots :y))
                                               (window-y cur-win)))))
                    (let ((mask (find-value :CODE event-slots)))
                      (case mask
                        (1 (setq op 'move) t)
                        (2 (zoom-to-window cur-win 'left) (focus-window cur-win) t)
                        (3 (setq op 'resize) t)
                        (4 (scale-down (min 6 (- *current-scale* 100)))
                         ;;(funcall pan-centered)
                         (if (= *current-scale* 100)
                             :done
                             t))
                        (5 (scale-up 6) #|(funcall pan-centered)|# t))))
                   (:button-release
                    (unless (and (= 0 (point-x *current-offset*))
                                 (= 0 (point-y *current-offset*)))
                      (pan-desktop-visual 0 0)
                      (pan-group (point-x *current-offset*)
                                 (point-y *current-offset*))
                      (setf (point-x *current-offset*) 0)
                      (setf (point-y *current-offset*) 0))
                    (setq op nil)
                    (setq cur-win nil)
                    (setq win-x-diff 0)
                    (setq win-y-diff 0)
                    t)
                   (:motion-notify
                    (let ((cur-x (getf event-slots :x))
                          (cur-y (getf event-slots :y))
                          (diff-x (- (getf event-slots :x) prev-x))
                          (diff-y (- (getf event-slots :y) prev-y)))
                      (cond
                        ((equal cur-win nil) t)
                        ((equal cur-win 'root-window)
                         ;; Multiply by two to make motion easier.
                         ;;
                         (pan-desktop-visual
                          (round (* (* 2 diff-x) (/ *current-scale* 100)))
                          (round (* (* 2 diff-y) (/ *current-scale* 100)))))
                        (T
                         (case op
                           (move (float-window-move-resize
                                  cur-win
                                  :x (- (scale-value cur-x) win-x-diff)
                                  :y (- (scale-value cur-y) win-y-diff)))
                           (resize (float-window-move-resize
                                    cur-win
                                    :width (+ (window-width cur-win) (scale-value diff-x))
                                    :height (+ (window-height cur-win) (scale-value diff-y)))))))
                      (setq prev-x cur-x)
                      (setq prev-y cur-y))
                    t)
                   ;; We need to eat these events or they'll ALL
                   ;; come blasting in later. Also things start
                   ;; lagging hard if we don't (on clisp anyway).
                   (:configure-notify t)
                   (:exposure t)
                   (:key-press
                    (let ((eventfn (gethash :key-press *event-fn-table*)))
                      (apply eventfn event-slots))
                    t)
                   (t nil))))))
    (xlib:grab-pointer (screen-root (current-screen))
                       '(:button-press
                         :button-release
                         :pointer-motion))
    (unwind-protect
         ;; Wait until the mouse button is released
         (loop for ev = (xlib:process-event *display*
                                            :handler #'overview-mouse-event-handler
                                            :timeout nil
                                            :discard-p t)
               until (eq ev :done))
      (ungrab-pointer)))))

;; TODO State mask
;; (multiple-value-bind (relx rely same-screen-p child state-mask)
;;    (xlib:query-pointer (window-parent window))
(defun root-window-click (screen button x y)
  (declare (ignore button))
  (let ((prev-x x) (prev-y y) (zoomed nil))
    (labels ((pan-screen-event-handler
                 (&rest event-slots &key event-key &allow-other-keys)
               ;; TODO: Use this for modifier support.
               ;; Returns (e.g.): (BUTTON-1 MOD4)
               ;;(echo (xlib:make-state-keys (find-value :STATE event-slots)))
               (let ((mask (find-value :CODE event-slots)))
                 (case mask
                   ;; TODO: Pan desktop (plus move window?).
                   (1 'root-window-click-left)
                   ;; TODO: Reset scale?
                   (2 'root-window-click-middle)
                   ;; TODO: Check window position and move it according to scale.
                   (3 'root-window-click-right)
                   (4 (scale-down 6) #|(funcall pan-centered)|# (setq zoomed t))
                   (5 (scale-up 6) #|(funcall pan-centered)|# (setq zoomed t))))

               (if (not zoomed)
                   (case event-key
                     (:button-release :done)
                     (:motion-notify
                      (let ((cur-x (getf event-slots :x))
                            (cur-y (getf event-slots :y)))
                        ;; Multiply by two to make motion easier.
                        (pan-group (* 2 (- cur-x prev-x))
                                   (* 2 (- cur-y prev-y)))
                        (setq prev-x cur-x)
                        (setq prev-y cur-y))
                      t)
                     ;; We need to eat these events or they'll ALL
                     ;; come blasting in later. Also things start
                     ;; lagging hard if we don't (on clisp anyway).
                     (:configure-notify t)
                     (:exposure t)
                     (t nil))
                   :done)))
      (xlib:grab-pointer (screen-root screen) '(:button-release :pointer-motion))
      (unwind-protect
           ;; Wait until the mouse button is released
           (loop for ev = (xlib:process-event *display*
                                              :handler #'pan-screen-event-handler
                                              :timeout nil
                                              :discard-p t)
                 until (eq ev :done))
        (ungrab-pointer)))))

(add-hook *root-click-hook* 'root-window-click)
;;(remove-hook *root-click-hook* 'root-window-click)

(defun add-to-focus-history (win last-win)
  (setq *last-focused* (or last-win win)))

(add-hook *focus-window-hook* 'add-to-focus-history)

;;(defvar *search-order* (make-array 4 :initial-contents '("down" "right" "up" "left")))
;;(defvar *search-order* '("down" "right" "up" "left"))
(defvar *search-order* (list #'win-node-down #'win-node-right #'win-node-up #'win-node-left))

(defun make-win-geometry (win)
  (let* ((extents (get-win-extents win))
         (min-coords (first extents))
         (max-coords (second extents))
         (min-point (make-point
                     :x (first min-coords)
                     :y (second min-coords)))
         (max-point (make-point
                     :x (first max-coords)
                     :y (second max-coords)))
         (center-point (make-point
                        :x (/ (- (first max-coords) (first min-coords)) 2)
                        :y (/ (- (second max-coords) (second min-coords)) 2))))
    (%make-win-geometry
     :id (xlib:window-id (window-xwin win))
     :center center-point
     :min min-point
     :max max-point)))

(defun fmap (functions &rest args)
  (declare (dynamic-extent args))
  "Applies each function to the arguments. Returns a list of results."
  (mapcar (lambda (function) (apply function args))
          functions))

(defun rotate-list (list n)
  (cond ((plusp n)
         (rotate-list
          (append (rest list) (list (first list)))
                  (1- n)))
         ((minusp n)
          (rotate-list
           (append (last list) (butlast list))
                   (1+ n)))
         (t list)))

(defun enqueue-edges (win visited queue num)
  (map nil (lambda (edge) (cl-containers:enqueue queue edge))
         (reduce (lambda (lst i)
                   ;;(let* ((func (intern (string-upcase (concat "win-node-" i)))))
                     (if (or (null (edge-target-node (funcall i win)))
                             (null (gethash (edge-target-node (funcall i win)) visited)))
                         (cons (funcall i win) lst)
                         lst));;)
                 (rotate-list (reverse *search-order*) num) :initial-value nil)))

(defun geom->corners (geom)
  "(upper-left upper-right bottom-left bottom-right)"
  (list
   (make-point
    :x (point-x (win-geometry-min geom))
    :y (point-y (win-geometry-min geom)))
   (make-point
    :x (point-x (win-geometry-max geom))
    :y (point-y (win-geometry-min geom)))
   (make-point
    :x (point-x (win-geometry-min geom))
    :y (point-y (win-geometry-max geom)))
   (make-point
    :x (point-x (win-geometry-max geom))
    :y (point-y (win-geometry-max geom)))))

(defun graph->geom-list (graph)
  (loop
    for key being the hash-keys in graph using (hash-value node)
    collect (win-node-geometry node) into lst
    finally (return lst)))

(defun andmap (fn data)
  (if (= (length data) 1)
      (funcall fn (car data))
      (if (funcall fn (car data))
          (andmap fn (cdr data))
          nil)))

(defun check-point-inside-geom (point geom)
    (and (<= (point-x (win-geometry-min geom))
            (point-x point))
         (>= (point-x (win-geometry-max geom))
            (point-x point))
         (<= (point-y (win-geometry-min geom))
            (point-y point))
         (>= (point-y (win-geometry-max geom))
            (point-y point))))

;; NOTE: This is slightly complicated.
;; The following two functions check for overlap.
;; These are necessary because a distance of 0 between
;; two windows is allowed, but no less.
;; If a distance of 0 were allowed, the above function
;; could simply be changed from (< >) --> (<= =>).
(defun equal-geom (geom1 geom2)
  "Check if two geometries are equal (total overlap)"
  (and (= (point-x (win-geometry-min geom1))
          (point-x (win-geometry-min geom2)))
       (= (point-y (win-geometry-min geom1))
          (point-y (win-geometry-min geom2)))
       (= (point-x (win-geometry-max geom1))
          (point-x (win-geometry-max geom2)))
       (= (point-y (win-geometry-max geom1))
          (point-y (win-geometry-max geom2)))))

(defun equal-geom-axis (geom1 geom2 coord1 coord2)
  "Check if two geometries overlap exactly on an axis.
   A clever solution wasn't immediately apparent, so this is used."
  (and (= (funcall coord1 (win-geometry-min geom1))
          (funcall coord1 (win-geometry-min geom2)))
       (= (funcall coord1 (win-geometry-max geom1))
          (funcall coord1 (win-geometry-max geom2)))
       (or
        (and (< (funcall coord2 (win-geometry-min geom1))
                (funcall coord2 (win-geometry-max geom2)))
             (> (funcall coord2 (win-geometry-min geom1))
                (funcall coord2 (win-geometry-min geom2))))
        (and (< (funcall coord2 (win-geometry-max geom1))
                (funcall coord2 (win-geometry-max geom2)))
             (> (funcall coord2 (win-geometry-max geom1))
                (funcall coord2 (win-geometry-min geom2))))
        (and (< (funcall coord2 (win-geometry-min geom2))
                (funcall coord2 (win-geometry-max geom1)))
             (> (funcall coord2 (win-geometry-min geom2))
                (funcall coord2 (win-geometry-min geom1))))
        (and (< (funcall coord2 (win-geometry-max geom2))
                (funcall coord2 (win-geometry-max geom1)))
             (> (funcall coord2 (win-geometry-max geom2))
                (funcall coord2 (win-geometry-min geom1)))))))

(defun check-overlap (geom graph)
  (format t "Checking overlap of ~a~%" geom)
  (loop for key being the hash-keys in graph using (hash-value other-node)
        for other-geom = (win-node-geometry other-node)
        for (ul ur bl br) = (geom->corners geom)
        for (other-ul other-ur other-bl other-br) = (geom->corners other-geom)
        ;; Lambda functions don't appear to work in LOOP macros, so
        ;; these are explicitly delineated.
        for overlap = (or (check-point-inside-geom ul other-geom)
                          (check-point-inside-geom ur other-geom)
                          (check-point-inside-geom bl other-geom)
                          (check-point-inside-geom br other-geom)
                          (check-point-inside-geom other-ul geom)
                          (check-point-inside-geom other-ur geom)
                          (check-point-inside-geom other-bl geom)
                          (check-point-inside-geom other-br geom))
                          ;;(equal-geom-axis geom other-geom #'point-x #'point-y)
                          ;;(equal-geom-axis geom other-geom #'point-y #'point-x)
                          ;;(equal-geom geom other-geom))
        when overlap
          do (return nil)
        finally (return geom)))

(defun make-adjacent-region (source width height side)
  (dformat 0 "mar:  height: ~a width: ~a~%" height width)
  (cond
    ((equal side 'up)
     (%make-win-geometry
      :center (make-point
               :x (point-x (win-geometry-center source))
               :y (1- (round (- (point-y (win-geometry-min source))
                                (/ height 2)))))
      :min (make-point
            :x (round (- (point-x (win-geometry-center source))
                         (/ width 2)))
            :y (1- (- (point-y (win-geometry-min source))
                  height)))
      :max (make-point
            :x (round (+ (point-x (win-geometry-center source))
                         (/ width 2)))
            :y (1- (point-y (win-geometry-min source))))))
    ((equal side 'down)
     (%make-win-geometry
      :center (make-point
               :x (point-x (win-geometry-center source))
               :y (1+ (round (+ (point-y (win-geometry-max source))
                                (/ height 2)))))
      :min (make-point
            :x (round (- (point-x (win-geometry-center source))
                         (/ width 2)))
            :y (1+ (point-y (win-geometry-max source))))
      :max (make-point
            :x (round (+ (point-x (win-geometry-center source))
                         (/ width 2)))
            :y (1+ (+ (point-y (win-geometry-max source))
                      height)))))
    ((equal side 'left)
     (%make-win-geometry
      :center (make-point
               :x (1- (round (+ (point-x (win-geometry-center source))
                                (/ width 2))))
               :y (point-y (win-geometry-center source)))
      :min (make-point
            :x (1- (- (point-x (win-geometry-min source))
                      width))
            :y (round (- (point-y (win-geometry-center source))
                         (/ height 2))))
      :max (make-point
            :x (1- (point-x (win-geometry-min source)))
            :y (round (+ (point-y (win-geometry-center source))
                         (/ height 2))))))
    ((equal side 'right)
     (%make-win-geometry
      :center (make-point
               :x (1+ (round (+ (point-x (win-geometry-center source))
                            (/ width 2))))
               :y (point-y (win-geometry-center source)))
      :min (make-point
            :x (1+ (point-x (win-geometry-max source)))
            :y (round (- (point-y (win-geometry-center source))
                         (/ height 2))))
      :max (make-point
            :x (1+ (+ (point-x (win-geometry-max source))
                      width))
            :y (round (+ (point-y (win-geometry-center source))
                         (/ height 2))))))))

;; TODO Make BFS runner for each node.
(defun find-window-location (geom root-win-key graph)
  "Takes a specified window geometry and finds a place for that
   window as close to the current window as possible"
  (let* ((root-node (gethash root-win-key graph))
         (queue (make-instance 'cl-containers:basic-queue))
         (current-side 0)
         (width (- (point-x (win-geometry-max geom)) (point-x (win-geometry-min geom))))
         (height (- (point-y (win-geometry-max geom)) (point-y (win-geometry-min geom)))))
    (cond
      ((not (null root-node))
       (format t "Root node is not null~%")
       (enqueue-edges root-node (make-hash-table) queue current-side)
       (loop
         ;; with candidates = nil
         with visited = (make-hash-table)
         while (not (cl-containers:empty-p queue))
         for edge = (cl-containers:dequeue queue)
         ;;for null-edge = (equal (edge-dist edge) 'inf)
         for source = (win-node-geometry (gethash (edge-source-node edge) graph))
         ;; for target = (win-node-geometry (gethash (edge-source-node edge) graph))
         for place =(cond
                      ((equal (edge-dist edge) 'inf)
                       (check-overlap (make-adjacent-region source width height (edge-dir edge)) graph))
                      ((and (eq (edge-dir edge) 'up) (<= height (edge-dist edge)))
                       (check-overlap (make-adjacent-region source width height 'up) graph))
                      ((and (eq (edge-dir edge) 'down) (<= height (edge-dist edge)))
                       (check-overlap (make-adjacent-region source width height 'down) graph))
                      ((and (eq (edge-dir edge) 'left) (<= width (edge-dist edge)))
                       (check-overlap (make-adjacent-region source width height 'left) graph))
                      ((and (eq (edge-dir edge) 'right) (<= width (edge-dist edge)))
                       (check-overlap (make-adjacent-region source width height 'right) graph)))
         when (not (null place))
           collect place into candidates
         do (format t "Candidates ~a~%" candidates)
         do (incf current-side)
         do (when (not (null (edge-target-node edge)))
              (format t "Target node: ~a~%" (edge-target-node edge))
              (enqueue-edges (gethash (edge-target-node edge) graph) visited queue current-side))
         do (setf (gethash (edge-target-node edge) visited) t)
         finally (return (or candidates geom))))
      ((null root-node)
       (format t "Root node is null~%")
       (list geom)))))

#|when null-edge
collect (check-overlap (make-adjacent-region source width height (edge-dir edge)) graph) into candidates
when (and (not null-edge) (eq (edge-dir edge) 'up) (<= height (edge-dist edge)))
collect (check-overlap (make-adjacent-region source width height 'up) graph) into candidates
when (and (not null-edge) (eq (edge-dir edge) 'down) (<= height (edge-dist edge)))
collect (check-overlap (make-adjacent-region source width height 'down) graph) into candidates
when (and (not null-edge) (eq (edge-dir edge) 'left) (<= width (edge-dist edge)))
collect (check-overlap (make-adjacent-region source width height 'left) graph) into candidates
when (and (not null-edge) (eq (edge-dir edge) 'right) (<= width (edge-dist edge)))
collect (check-overlap (make-adjacent-region source width height 'right) graph) into candidates|#

(defun node-side-edge (geom win-list id side)
  (multiple-value-bind (node dist)
      (locate-closest-window geom win-list (string-downcase (symbol-name side)))
    (make-edge :source-node id :target-node node :dir side :dist (or dist 'inf))))
;; TODO Make function to check the sides of each node.

;; TODO
;; Make hashtable with xwin ID as the key.
;; Window node as the value.
;; Look at pan-window and find-window-to-side for filling the slots in the node.
;;
(defun new-node-in-graph (init-geom root-node graph &key win)
  (let* ((win-list (graph->geom-list graph))
         (geom-candidates (find-window-location init-geom root-node graph))
         (geom (car (remove-if #'null geom-candidates)))
         (id (win-geometry-id init-geom)))
    (setf (win-geometry-id geom) id)
    (format t "Candidates ~S~%" geom-candidates)
    (make-win-node
     :win win
     :id id
     :geometry geom
     :up (node-side-edge geom win-list id 'up)
     :down (node-side-edge geom win-list id 'down)
     :left (node-side-edge geom win-list id 'left)
     :right (node-side-edge geom win-list id 'right))))

;; TODO Update other windows in graph
;; Probably just re-evaluate the windows on each side of the current window.
(defun update-node-edges (node graph)
  (let* ((win-list (graph->geom-list graph))
         (geom (win-node-geometry node))
         (id (win-node-id node)))
    (setf (win-node-up node) (node-side-edge geom win-list id 'up))
    (setf (win-node-down node) (node-side-edge geom win-list id 'down))
    (setf (win-node-left node) (node-side-edge geom win-list id 'left))
    (setf (win-node-right node) (node-side-edge geom win-list id 'right))))

(defun update-all-edges (graph)
  (loop
    for key being the hash-keys in graph using (hash-value node)
    do (update-node-edges node graph)))

(defun add-win ()
  (let* ((root-node (xlib:window-id (window-xwin (if (not (null *last-focused*)) *last-focused* (current-window)))))
         (new-node (new-node-in-graph
                    (make-win-geometry (current-window))
                    root-node
                    *window-graph*
                    :win (current-window)))
         (geom (win-node-geometry new-node)))
    (setf (gethash (win-node-id new-node) *window-graph*) new-node)
    (update-all-edges *window-graph*)
    (float-window-move-resize
     (win-node-win new-node)
     :x (point-x (win-geometry-min geom))
     :y (point-y (win-geometry-min geom))
     :width (- (point-x (win-geometry-max geom))
               (point-x (win-geometry-min geom)))
     :height (- (point-y (win-geometry-max geom))
                (point-y (win-geometry-min geom)))))
  (echo "Added window to graph."))

(defvar *test-graph* (make-hash-table))
(defvar *init-geom*
  (%make-win-geometry
   :id 16777221
   :center (make-point :x 479 :y 588)
   :min (make-point :x 0 :y 0)
   :max (make-point :x 958 :y 1176)))
(defvar *init-node*
  (make-win-node
   :win nil
   :id (win-geometry-id *init-geom*)
   :geometry *init-geom*
   :up (make-edge :source-node (win-geometry-id *init-geom*) :target-node nil :dir 'up :dist 'inf)
   :down (make-edge :source-node (win-geometry-id *init-geom*) :target-node nil :dir 'down :dist 'inf)
   :left (make-edge :source-node (win-geometry-id *init-geom*) :target-node nil :dir 'left :dist 'inf)
   :right (make-edge :source-node (win-geometry-id *init-geom*) :target-node nil :dir 'right :dist 'inf)))
(setf (gethash (win-node-id *init-node*) *test-graph*) *init-node*)
(defun print-graph (graph)
  (loop
    for key being the hash-keys in graph using (hash-value node)
    do (print node)))

;;(add-hook *new-window-hook* 'add-window-to-graph)

;; TODO
;; Call every time a window is moved.
;; Change the window's closest neighbors.
;; Find all instances of it and update the nodes where it has changed.
;;(defun update-window-graph (win))

;; TODO
;; Call every time a window is removed from the list.
;; Remove its place in the hash table and update all nodes that have an edge to it.
(defun remove-window-from-graph (win)
  (remhash (xlib:window-id (window-xwin win)) *window-graph*)
  (update-all-edges *window-graph*))

(add-hook *destroy-window-hook* 'remove-window-from-graph)

;; Clear rules
(clear-window-placement-rules)

;; Last rule to match takes precedence!
;; TIP: if the argument to :title or :role begins with an ellipsis, a substring
;; match is performed.
;; TIP: if the :create flag is set then a missing group will be created and
;; restored from *data-dir*/create file.
;; TIP: if the :restore flag is set then group dump is restored even for an
;; existing group using *data-dir*/restore file.
;;(define-frame-preference "Default"
;;  ;; frame raise lock (lock AND raise == jumpto)
;;  (0 t nil :class "Konqueror" :role "...konqueror-mainwindow")
;;  (1 t nil :class "XTerm"))


;;(defvar *global-bar* (make-input-bar))

#|(defcommand start-global-bar () (:rest)
  "Read a command from the user. @var{initial-text} is optional. When
supplied, the text will appear in the prompt."
  (let ((cmd (completing-bar-read *global-bar* ": " (all-commands))))
    ;;(unless cmd
    ;;  (throw 'error :abort))
    (when (plusp (length cmd))
      ;;(eval-command cmd t)
      (echo cmd))))|#

#|(defcommand start-bar (bar) (:rest)
  "Read a command from the user. @var{initial-text} is optional. When
supplied, the text will appear in the prompt."
  (let ((cmd (completing-bar-read bar ": " (all-commands))))
    (unless cmd
      (throw 'error :abort))
    (when (plusp (length cmd))
      ;;(eval-command cmd t)
      (echo cmd))))|#

(run-shell-command "compton --dbus")
(run-shell-command "feh --bg-center ~/Pictures/background.png")
(run-shell-command "redshift")
